% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage[latinica]{matfmaster}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
\usepackage{pangrami}
\usepackage[x11names]{xcolor}
\usepackage{numprint}

% Paket koji obezbeđuje ispravni prikaz ćiriličkih italik slova kada
% se koristi pdflatex. Zakomentarisati ako na sistemu koji koristite ovaj
% paket nije dostupan ili ako ne radi ispravno.
\usepackage{cmsrb}

% Ostali paketi koji se koriste u dokumentu
\usepackage{listings} % listing programskog koda

% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Luka B. Đorović}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Analiza slučajeva upotrebe relacionih i kolonski orijentisanih nerelacionih baza podataka}
% Godina u kojoj je teza predana komisiji
\godina{2024}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Saša \textsc{Malkov}, vandredni profesor\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Ана \textsc{Анић}, ванредни професор\\ University of Disneyland, Недођија}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Лаза \textsc{Лазић}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{15. јануар 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{анализа, геометрија, алгебра, логика, рачунарство, астрономија}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Ovaj rad posvećujem...}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Uvod}
% ------------------------------------------------------------------------------

Podaci su najstabilniji deo svakog sistema. Oni su reprezentacija činjenica, koncepata jednog sistema kao i instrukcija u formalizovanom stanju spremnom za dalju interakciju, interpretaciju ili obradu od strane korisnika ili mašine. Iako kroz svoju istoriju računatstvo važi za oblast koja uvodi nove tehnologije i alate neverovatnom brzinom to  nije slučaj za svaku njenu granu. Postoje oblasti koje se kroz istoriju nisu menjali, ili su se slabo menjali i proširivali. Primera za to ima puno i oni su uglavnom usko vezani za funkcionalne principe koji se prožimaju kroz računarske mreže, kompilatore, operativne sisteme, sisteme za upravljanje podacima itd. 

Kada je reč o istoriji sistema za upravljanje podacima, izdvojio bih tri glavne faze: vreme pre relacionih sistema, vreme neprikosnovene vladavine relacionih sistema i nastanak alternativa relacionim sistemima pod grupnim nazivom NoSQL.

Do 70ih i nastanka relacionih sistema za upravljanje podacima, rukovanje podacima izvodilo se kroz pisanje i čitanje sa fajl sistema operativnog sistema. Rukovanje većim količinama podataka nije bilo standardizovano ni na koji način već su se konvencije uvodile na nivou organizacija. Apolo sletanje na Mesec realizovano je koristeći ovakav vid rada sa podacima, što ovaj poduhvat čini utoliko neverovatnim. 

S obzirom da je ovaj vid rada sa podacima imao mnogbrojne mane, među kojima je jedan od glavnih bio težak pristup podacima, javile su se potrebe za unapređenjem. Najuspešniji je bio Edgar F. Codd \footnote{Edgar Frank "Ted" Codd (19 Avugst 1923 – 18 April 2003) Američki računarski naučnik }  koji je 1970. godine objavio rad pod imenom "A Relational Model of Data for Large Shared Data Banks" kao rezultat istraživanja i sopstvenih teorija o organizaciji podataka.  Kao dokaz da je njegov model moguće implementirati pokrenut je System R, čiji je rezultat bio i pojava SQL-a (Structured Query Language) kao standardizovanog jezika za rad sa podacima. Nakon toga pojavili su se Oracle i IBM sa svojim komercijalnim proizvodima za upravljanje relacionih baza podataka. Naredni period obeležio je rad sa podacima koristecći relacioni model.  

XXI vek doneo je sa sobom ubrzanu digitalizaciju, povećanu dostpunost interneta, samim tim pojavila se potreba za obradom veće količine podataka. Sve ovo je pokazalo pojedine slabosti dosadašnjih sistema zasnovane na relacionim modelima, koji nisu mogli u svim segmentima da odgovore na zahteve modernog doba. Ovi problemi obično su poznati pod gruonim imenom "problemi velikih podataka" (BigData problems). Došlo je do pojave niza novih modela i principa za čuvanje podataka, a svi pod grupnim imenom "NoSQL" (ili nerelacione) baze podataka.
Sistematizovanje ogromne količine fizičkog prostora na disku na kojem se podaci mogu čuvati i kasnije koristiti, kao i fleksibilnost strukture podataka sa kojima se radi , jesu glavni aktuelni problemi tog vremena na koje su se fokusirale tehnologije nastale u NoSQL pokretu.
Decenije vladavine  relacionih sistema za čuvanje podataka ostavile su dubok trag u praksama rada sa podacima, i sa razlogom predstavljaju defakto standard i dan danas, te je zaočekivati postojanje doze skepse pri korišćenju tehnologija nastalih u ovoj fazi. 

Kao važna grupa nerelacionih izdvajaju se kolonski-orijentisane baze podataka. One su uvele tada nekonvencionalne koncepte čuvanja podataka po kolonama. Dakle fizički na disku skladištile su se vrednosti jedne kolone jedna do druge, sa referencom na red kojem pripadaju. To sa sobom vuče razne mogućnosti za optimizaciju ali i novih pristupa modelovanja i organizacije podataka. Ovakav način skladištenja ispitavan je još davnih 70ih godina XX veka, međutim u ranim godinama XXI veka došlo je do obnove interesovanja u akademskim ali i industrijskim krugovima. 

Nijedan od navedenih koncepata nije univerzalno rešenje, zato je bitno postojanje materijala koji se bave analizom slučajeva upotrebe tih tehnologija. Pored teorijske analize koja se može pronaći u relevantnim javnim dokumnetacijama korisno je imati i konkretne implementacije testova čiji se rezultati mogu iskoristiti kako bi se povukle paralele u skladu sa potrebama realnih  sistema. 

Cilj ovog rada je analiza i upoređivanje slučajeva upotrebe relacionih i kolonski orijentisanih baza podataka. Rad će se sastojati iz teorijskog opsia navedenih tehnologija kao i opisa konkretnih predstavnika baza podataka koji će biti korišćeni. Na osnovu teorijskih izbora i istraživanja biće analizirani različiti slučajevi upotrebe. 


% ------------------------------------------------------------------------------
\chapter{Modeli za upravljanje podacima}
\label{chp:razrada}
\section{Relacioni model}
\subsection{Opšte karakteristike}
Relacioni model je najpopularniji model za rad sa podacima. On podatke kao i veze izmedju njih predstavlja kroz skup relacija. Kao fundamentalna ideja iza relacionog modela stoji tabelarni prikaz podataka, sto uvecava njegovu intuitivnost. Da bi jedna tabela bila validna relacija u relacionom modelu ona mora ispunjavati sledeće uslove:

\begin{enumerate}
\item[\textbullet] Presek kolone i vrste jedinstveno određuje vrednosnu ćeliju.

\item[\textbullet] Sve vrednosne ćelije jedne kolone pripadaju nekom zajedničkom skupu. 

\item[\textbullet] Svaka kolona ima jedinstveno ime.

\item[\textbullet] Ne postoje dve identične vrste jedne tabele. 
\end{enumerate}

Iako ovakva formalizacija relacije deluje intuitivno (usled istorijskog uticaja koji je relacioni model ostavio na vizualizaciju organizacije podataka) ona je neophodna za  definisanje složenijih pojmova. 

\subsection{Koncept ključa relacionog modela}

Usled jedinstvenosti svake vrste relacije, jasno je da mora postojati skup kolona za koji važi da nikoja dva reda te relaciju nemaju identične vrednosti za svaku kolonu iz tog skupa. Takav skup se naziva \textit{superključ} relacije. Minimalan superključ naziva se \textit{ključ kandidat}. Svaka relacija može imati više ključeva kandidata, ali samo jedan od njih je  \textit{primarni ključ} koji mora imati definisanu vrednost za svaku njegovu kolonu.
\textit{Strani ključ} je kolona ili skup kolona čije vrednosti predstavljaju referencu na određeni red neke druge relacije. Primarni i strani ključ igraju veliku ulogu u očuvanju integriteta baze podataka o čemu ce biti reči u nastavku.

\subsection{Integritet relacionog modela}
Integritet relacionog modela predstavlja "istinitost"  podataka koji se čuvaju u bazi, što je njena i najveća vrednost. Čuvanje integriteta baze posebno je važno  prilikom invazivnih operacija kao što su dodavanje reda, izmena reda ili brisanje reda u tabeli. Postoji više vrsta integriteta u relacionom modelu: \textit{integritet entiteta}, \textit{integritet domena}, \textit{integritet neposojece vrednosti} i \textit{referencijalni integritet}.

 \textit{Integritet entiteta} kaže da svaka vrsta jedne relacije predstavlja jedan entitet i da kao takva ne može u okviru primarnog ključa, koji taj entitet identifikuje, imati nedefinisanu ili nepostojeću vrednost.

\textit{Integritet domena} nameće shemu po kojoj svaka kolona može uzimati vrednost iz unapred dodeljenih skupova vrednosti. 

\textit{Integritet nepostojece vrednosti} govori o eventulnim kolonama cije vrednosti ne mogu kao vrednost imatu nepostojecu vrednost kako se ne bi narušila uspostavljena biznis logika. 

\textit{Referencijalni integritet} nalaže da se svaki strani kljuc jedne tabele, ukoliko je definsan,  mora poklapati sa nekim od primarnih ključeva uparene relacije.

\subsection{PostgreSQL}


PostgreSQL je objektno-relacioni sistem za upravljanje bazama podatak nastao kao potomak POSTGRES-a, proizvoda koji je nastao, a kasnije i razvijan na Berkliju, Univerzitet Kalifornija. PostgreSQL je otvorenog koda sa velikom SQL podrškom kao i modernim funkcionalnostima poput: kompleksnih upita, okidača, izmenjivih pogleda, transakcionog integriteta i mnogih drugih. Postgres nudi širok spektar proširenja od strane korisnika poput dodavanja novih tipova podataka, funkcija, operatora, agregagtnih funkcija itd. 

Kao takav, PostgreSQL je pogodan sistem za čuvanje najkompleksnijih podataka i veza između njih. Mogućnost kreiranja procedura na samoj bazi u integrisanoj SQL sintaksi, daje široke mogućnosti optimizacije aplikacija. 

PostgresSQL koristi server-klijent model funkcionisanja. Sastoji se iz serverskog i klijentskog dela procesa. Serverski deo rukuje fajlovima baze podataka, prihvata konekcije, izvršava konkretne operacije nad bazom. Klijentski deo predstavlja aplikaciju kojom korisnik može da komunicira i rukuje podacima na serverskom delu. Klijent i server komunkciraju preko TCP/IP protokola. Serverski deo može raditi sa više konekcija istovremeno tako što svaka klijentska konekcija radi kao zaseban proces.

Postgres iza sebe ima razvijenu društvenu zajednicu, pa samim tim ima dosta izvora i dokumentacije koje mogu olakšati učenje ovog sistema.  \cite{PostgreSQLUpAndRunning}

\section{Kolonski-orijentisani model}
% ------------------------------------------------------------------------------
\subsection{Opšte karakteristike}
\cite{ColumnarOriented}
Susret sa Big Data problemima dovelo je do potreba za tabelama koje imaju ogroman broj kolona, i ogroman broj redova u okviru tih tabela. Jasno je da nam je za potrebe različitih analitika potreban različit skup kolona. Novonastali zahtevi ukazali su na problem kod postojećih  relacionih modela. Svaki upit nad tabelom podrazumevao je dohvatanje svih kolona jednog reda, gde bi se filtriranje nepotrebnih kolona izvršavalo nakon što su se sve kolone učitale u memoriju. Ovo je bila samo jedna od motivacija za implemetanciju sistema zasnovanih na kolonski orijentisanom modelu koji je dizajniran tako da ovakav problem izbegne i uz to donese i druga poboljšanja o kojima će biti reči u nastavku.

Kao što mu ime govori kolonski orijentisan model podatke na disku skladišti po kolonama a ne po redovima kao što je to slučaj kod relacionh modela. U prevodu, sve vrednosti kolone svih redova skladište se jedna do druge, a na konkretnu vrednosnu ćeliju referiše se pomoću ključa konkretnog reda kao i kolone čiju vrednost želimo da pročitamo. Ovakav dizajn doveo je do toga da za dohvatanje određenog skupa kolona nema potrebe da čitamo sve vrednosti tog sloga, već je dovoljno da znamo konkretan ključ tog reda kao i imena kolona čije vrednosti želimo da pročitamo.

Ovakav vid skladištenja sa sobom nosi veliki potencijal za primenu raznih algoritama za kompresiju podataka.  Kompresija nad sličnim podacima koji se nalaze na uzastopnim adresama u memoriji, omogućava izbegavanje čuvanja složenih meta informacija u okviru struktura koje se koriste za tu kompresiju što ovaj model čini posebno pogodnim za njihovu primenu.

Nedostajanje unapred definisanog skupa kolona, ukida smisao čuvanja nepostojeće vrednosti (null) s obzirom da ukoliko  red nema vrednost neke kolone, nema potrebe za upisivanjem bilo koje vrednosi te kolone za taj red.

Kolonski orijentisan model kao i većina ostalih nerelacionih modela, nudi fleksibilnost sheme. To kao posledicu ima da eventualna promena strukture podataka neće bitno uticati na unapred definisanu shemu, kao ni iziskivati dodatnu migraciju podataka, kao sto bi to bio slucaj kod relacionog modela. Osim toga fleksibilnost sheme se ogleda i u tome sto je broj kolona jednog vektora neogranicen, sto daje dosta prostora za eksperimentisanje sa dizajnom baze. Primer toga kako ovakvo svojstvo modela može doprineti dostizanju prednosti pri analitičkom sistemu možete videti na slici SLIKA 1. 
\begin{figure}[!ht]
  \vspace*{4cm}
  \centering
  \includegraphics[width=0.9\textwidth]{relational-column-oriented.png}
  \caption{Kolonski orijentisan format}
  \label{fig:grafikon}
\end{figure}

\subsection{Popularni algoritmi kompresije kolonski orijentisanog modela}
\cite{ColumnarOptimizations}
\subsubsection{Enkodiranje zasnovano na rečniku}

Enkodiranje zasnovano na rečniku (Dictionary based encoding) jeste tehnika kompresije podataka koja se može primeniti na vrednosti jedne kolone ili skupa kolona. Najefikasnija je nad kolonama koje imaju mali skup mogućih vrednosti. Rade tako što se u memoriji sačuvaju sve moguće vrednosti te kolone i svakoj od njih se dodeli ključ. Veličina ključa je direktno zavisna od kardinalnosti skupa vrednosti koje se mapiraju. Svaki unos ili izmena vrednosti kolone u konsultaciji sa postojećim rečnikom radi enkodiranje pristigle vrednosti, a svako dohvatanje vrednosti radi dekodiranje sačuvane vrednosti. Ovim se izbegava ponavljanje velikih podataka tako smanjujući potrebnu memoriju na disku. Uglavnom su pogodne primene nad kolonama sa statičkim i opisnim podacima koji se ponavljaju.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{DictionaryEncoding.jpg}
  \caption{Enkodiranje zasnovano na recniku}
  \label{fig:grafikon}
\end{figure}


\subsubsection{Enkodiranje po broju ponavljanja}

Enkodiranje po broju ponavljanja (Run Length Encoding) je jednostavan mehanizam za kompresiju podataka pogodan kompresiju kolona kod koje se vrednosti ponavljaju. Funkcioniše tako što kada se naiđe na vrednost koja se ponavlja, ne skladišti duplikate već sačuva tu vrednost jednom a dodatno kao meta informaciju prosledi koliko puta se ta vrednost ponavlja. Takav vid optimizacije najkorisnije je očigledno kada su vrednosti sortirane, a s obzirom da su vrednosti kolona u kolonski orijentisanim bazama jedna do druge to otvara prostor za ovaj vid kompresije podataka kako bi se umanjilo zauzeće prostora.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{run-length-encoding.jpg}
  \caption{Enkodiranje po broju ponavljanja}
  \label{fig:grafikon}
\end{figure}

\subsubsection{Delta enkoding}
Delta enkoding je mehanizam za optimizaciju prostora baze podataka koji se zasniva na čuvanju razlike između objekata a ne celih vrednosti. Primera za upotrebu ima dosta a jedan od najčešćih je slučaj datumskih kolona, gde će nam referentna vrednost biti neki konkretan datum, a vrednosti ostalih kolona će biti čuvane kao razlika u odnosu na njega. Kao što je rečeno pogodna je za datumske vrednosti ali postoje i drugi tipovi, kao što su numerički, kod kojih ovaj vid kompresije može doneti unapređenja u vidu slobodnog prostora na disku.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{delta-encoding.png}
  \caption{Delta enkoding}
  \label{fig:grafikon}
\end{figure}

\subsection{HBase}

HBase je distribuirana kolonski orijentisana nerelaciona baza podataka  pisana u javi.  Nastala je 2007 kao prototip BigTable baze koja je modelovana u okviru Google-ovog članka 2006 \cite{BigTable}. 

Model podataka koji HBase koristi podrazumeva da se svaka tabela sastoji iz familije kolona, a da svaka familija kolona sadrži određeni broj atributa nekog reda. Cilj je da atributi, odnosno kolone koje su po prirodi slične pripadaju istoj familiji kolona, kako bi se nad njima mogli primeniti algoritmi kompresije, s obizrom da će se kolone koje pripadaju jednog familije sladištiti blizu na disku. Hbase nudi fleksibilnost sheme, pa s toga da bismo neki podatak skladištili ne moramo unapred da definišemo skup kolona koji pripada nekoj tabeli , ali moramo definisati skup familija kolona te tabele kako bi bilo moguće odrediti pogodnu lokaciju skladištenja podatka.

HBase ne podržava postojanje indeksa, međutim podrazumevano ponašanje je da su ključevi svih redova sortirani rastuće, tako da se koristi binarna pretraga za pretragu vredosnti po ključu reda kojem pripada. Ovo daje na važnosti strategiji pro dizajniranju ključa. Poželjno je da svaka pretraga ide direktno preko ključa ili njegovog prefiksa. 

Vrednosnu ćeliju u HBase tabeli određuje ključ reda, ime kolone te vrednosne ćelije, kao i familija kojoj kolona pripada.

HBase nije ACID baza podataka, ali garantuje konzistentnost u radu sa jednim redom.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{colFamily.png}
  \caption{Hbase model}
  \label{fig:grafikon}
\end{figure}

Arhitektura HBase klastera sastoji se iz dve glavne komponente:  master server i region server.  Ove komponente je najbolje opisati kroz interfejse koje oni implementiraju. 

Region server implementira HRegionInterface, odnosno implementira servise koji se bave operacijama nad podacima i održavanjem i upravljanjem regiona. Jedan region čine podaci za redove u nekom rasponu vrednosti ključeva. Region server kreira i dohvata HFile fajlove koji se čuvaju na disku. HBase dozvoljava dva režima: samostalan i distribuirani režim.

Samostalan režim HFile fajlove može čuvati na lokalnom fajl sistemu i korišćenje HDFS-a je opciono.

U distribuiranom režimu sa druge strane neophodno je korišćenje HDFS-a za skladištenje. Region server možemo zamisliti kao indeks za dohvatanje HFile-ova sa sa diska.  Svaka izmena koja treba da se izvrši na disku prvo se upisuje u WAL (Write ahead log), a nova izmenjena vrednost se upisuje u MemStore fajl. Kada se MemStore fajl upuni tek tada se izmene flush-uju u jedan HFile koji dalje ide na HDFS. 

HMaster implementira HMasterInterface koji sadrži servise koji rade sa metainformacijama o tabelama, familijama kolona, kao i regiona. Uloga Mastera je da za svaki konkretan row id može da odredi koji region odnostno region server treba da bude pročitan kako bi se izvršila odgovarajuća operacija. Za postizanje navedene funkcionalnosti HMaster koristi Zookeeper \cite{BigTable} servis. Pored toga master servis ima pozadinske procese koji regulišu rad load balansera i sadržaj hbase:meta tabele.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{hbase-standalone.png}
  \caption{HBase standalone}
  \label{fig:grafikon}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{hbase-distributed.png}
  \caption{HBase distributed}
  \label{fig:grafikon}
\end{figure}


\pagebreak

\section{Glavne razlike između relacionog i kolonski-orijentisanog modela}


\subsection{Normalizacija i denormalizacija}

Da bi se stanje u bazi olakšalo čuvanje podataka konzitentnim u relacionim modelima često se radi na izbegavanju \textit{redudantnosti} u podacima. Redudantni podaci zauzimaju višak prostora na disku i otežavaju kasnije održavanje sistema. Kako bi se izbegla redudantnost postoji jasno definisani postupci koji nam pomažu da organizujemo podatke tako da redudantnost umanjimo. Proces unapredđivanja logičkog dizajna baze tako da rešava problem redundantosti podataka, ali ne po cenu očuvanja integriteta, naziva se normalizacija. Teorija o normalizaciji se zasniva nad konceptima normalnih formi iz matematičke logike. U zavisnosti od toga koja pravila zadovoljava određena relacija, dodeljuje joj se normana forma. Trenutno postoji 5 defnisanih normalnih formi. 

\begin{enumerate}
\item Prva normalna forma (1NF)
	\begin{enumerate}
	\item[\textbullet] Svaka relacija mora imati primarni ključ koja jedinstveno određuje svaku vrste.
	\item[\textbullet] Svaka kolona mora saržati atomičnu (nedeljivu) vrednost.
	\item[\textbullet] Sve vrednosti jedne kolone pripadaju nekom zajedničkom skupu.
	\end{enumerate}

\item Druga normalna forma (2NF)
	\begin{enumerate}
	\item[\textbullet] Relacija mora biti 1NF
	\item[\textbullet] Sve vrednsti kolone koje ne pripadaju superključu relacije, direktno su određene celim primarnim ključem .
	\end{enumerate}

\item Treća normalna forma (3NF)
	\begin{enumerate}
	\item[\textbullet] Relacija mora biti 2NF
	\item[\textbullet] Nijedna kolona van ključa kandidata nije jedinstveno određena drugim kolonama koje ne pripadaju  ključu kandidatu.
	\end{enumerate}

\item Boyce-Codd normalna forma (BCNF)
	\begin{enumerate}
	\item[\textbullet] Relacija mora biti 3NF.
	\item[\textbullet] Svaka kolona koja ne pripada ključu mora biti jednistveno određena vrednostima superključa relacije.
	\end{enumerate}

\item Četvrta normalna forma (4NF)
	\begin{enumerate}
	\item[\textbullet] Relacija mora biti BCNF.
	\item[\textbullet] Regulisanje zavisnostni među kolonama tako da nema ponavljanja podataka.
	\end{enumerate}

\item Peta normalna forma (5NF)
	\begin{enumerate}
	\item[\textbullet] Relacija mora biti 4NF.
	\item[\textbullet] Reguliše zavisnosti između relacija tako da se izbegne potreba za komplikovanim upitima za dohvatanje podataka.
	\end{enumerate}

\end{enumerate}

Modeli koji su bili podloženi normalizaciji obično raspolažu velikim brojem referencijalnih ključeva u tabelama koji predstavlaju referencu ka originalnim podacima iz matične tabele u kojoj se nalaze. Ukoliko želimo da pristupimo celom podatku iz neke tabele koja referiše na njega, podrazumeva se da ćemo pročitati celu tabelu na koju ta referenca pokazuje, što povećava broj operacija čitanja sa diska samim timmože uticati na performanse.

Denormalizacija je strategija kod modela gde je neophodno ubrzati operacije čitanja podataka, odnosno umanjiti broj tabela kojima je neophodno pristupiti kako bi se neki skup podataka pročitao iz baze podataka.  

Neke od tehnika denormalizacije su dodavanje redundantne kolone, horizontalna podelea tabele, vertikalna podela tabele, uvođenje izvedene kolone. 
Pre join kolone  je  dodavanje kolone tabeli čija se referenca na vrednost te kolone često koristi. 
Horizontalno deljenje tabele podrazumeva da se na osnovu prirode podataka jedna tabela podeli na više tabela tako da se čitanje svede samo na čitanje grupe redova. 
Vertikalno deljenje podrazumeva da se tabela podeli grupisanjem kolona koje se često čitaju zajedno. 
Uvođenje izvedene kolone predstavlja dodavanje kolone koja predstavlja vrednost neke agregatne funkcije, time se izbegava da se pri čitanju ta operacija izvršava, već se radi prosto čitanje.


\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{denormalizacija.png}
  \caption{Pre join kolone}
  \label{fig:grafikon}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{denormalizacija2.png}
  \caption{Horizontalna podela tabele}
  \label{fig:grafikon}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{denormalizacija3.png}
  \caption{Vertikalna podela tabele}
  \label{fig:grafikon}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{denormalizacija4.png}
  \caption{Uvođenje izvedene kolone}
  \label{fig:grafikon}
\end{figure}
\pagebreak

\subsection{ACID i BASE}


ACID (Atomicity, Consistency, Isolation, Durability) svojstva služe kao garancija tačnosti i konzistetnosti podataka prilikom konkurentnom pristupu. 

Atomicity se može objasniti pravilom: Jedna transakcija se izvršava u celini ili se ne izvršava nijedan njen deo. U prevodu, dejstvo transakcije je nedeljivo. 

Durability garantuje da će kompletirana transakcija u slučaju prekida rada sistema pre nego što su izmene reflektovane na disk, biti upamćena i izvršena nakon restarta sistema. Svaka izmena se upisjue u log fajl pre nego što je reflektovana na disk, kako bi se operacije mogle poništiti u slučaju poništavanja transakcije.

Consistency se čuva od strane korisnika. Bitno je da korisnik koji pokreće transakciju vodi računa o tome da stanje podataka ostane u konzistentom stanju.

Isolation svojstvo nalaže da se transakcije međusobno izolovane tako da izvršavanje jedne transakcije ne može uticati na izvršavanje druge. Ovo se obezbeđuje pomoću scheduler-a od strane samog sistema za upravljanje bazom podataka.

ACID svojstva obično su karakteristika relacionog modela.

BASE sa druge strane je skup svojstava koje je definisao Eric Brewer , a koja su nastala usled zelje da se formalizuju svojstva koja u Big Data svetu garantuju da je baza pogodna za horizontalno skaliranje a ujedno daje vid konzistentnosti koji je neophodan. 

Suštinska rasoloživost  svojstvo kaze da ukoliko imamo klaster sa vise pojedinačnih skladišta baze, problem sa jednim od njih nece spreciti da ostala skladišta procesiraju zahteve i salju odgovore.

Trenutno nekonzistento stanje -  svojstvo kaze da se stanje podataka moze menjati, cak i u trenucima kada nema spoljnih komunikacija sa bazom podataka.

Konvergentna konzistencija garantuje da ce baza podataka u periodima kada nema spoljne komunikacije sa klijentima, postati konzistentna kroz neki vremenski period. 

Kolonski orijentisan model načelno ne mora da ispunjava BASE svojstva, ali to obicno jeste slucaj upravo zbog horizontalnog skaliranja koja ima tendenciju da ponudi.

\subsubsection{CAP teorema}

U teoriji sistema za čuvanje podataka, CAP teorema koju je definsiao Eric Brewer, navodi da baza podatka koja skladišti deljene (distribuirane podatke) ne može istovremeno ispunjavati konzistentnost, raspoloživost, toleranciju razdvojenosti, slika 2.12.
Tolerancija razdvojenosti je svojstvo koje se obično pordazumeva i njegovo odsustvo sistem čini ne prihvatljivim u praksi. Ovo navodi da se od relaciono modela načelno očekuje da u distribuiranom okruženju osim tolerancije razdvojenosti nudi i konzistentost, za razliku od kolonski orijentisane nerelacione baze koja konzistetnost ne garantuje (ali garantuje konvergentnu konzistenciju) pa samim tim fleksibilnije radi nad deljenim podacima.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{cap.png}
  \caption{CAP teorema}
  \label{fig:grafikon}
\end{figure}

% ------------------------------------------------------------------------------
\chapter{Slučajevi upotrebe}
% ------------------------------------------------------------------------------
\section{Opis i sadržaj eksperimenta}
Analiza i upoređivanje slucajeva upotrebe bice realizovani na osnovu teorijskih i prakticnih  izvora i istrazivanja. Svaki primer ce biti pracen eksperimentom koji ce se sastojati od izvrsavanja razlicitih vrsta postupaka.

Kako bi se postigao dovoljan dokaz koncepta (eng. proof of concept), ali i doslednost modernom
vremenu, kategorije slucajeva upotrebe koji ce biti obuhvaceni su:
\begin{enumerate}
\item Onlajn transakciono procesiranje (OLTP)
\item Onlajn analiticko procesiranje (OLAP)
\item Primena u distribuiranom okruzenju
\end{enumerate}

Svakom slučaju upotrebe u okviru pripreme eksperimenata dodeljen je kontekst u skladu sa slučajem upotrebe koji se testira.  Kontekst obuhvata konkretan model podataka nad kojim se izvršavaju testovi.

Pored definisanja konteksta, analiza slučaja upotrebe sadržaće opis implementaicije testova nad predstavnicima, uputstvo za pripremu okruženja kao i analizu rezultata na kraju.

Analiza rezultata eksperimenta će pored prikaza rezultata samih merenja, obuhvatiti i upoređivanje složenosti realizacije konkretnog slučaja upotrebe, kao eventualna unapređenja i primedbe koje treba imatu u vidu kada se radi sa datim tehnologijama. 

\subsection{Platforma testiranja}

Kao okruženje za izvršavanje eksperimenata korišćen je docker.  Oba predstavnika bice pokrenuta u okviru nezavisnih kontejnera na jednom host-u sa docker engine-om. Svaki test predstavlja jedan java program koji se izvršava na konkretnom kontejneru, kako bi se smanjila potreba za evenutalnim saobraćajem kroz mrežu kako bi se tako stekla što objektivinija slika na osnovu rezultata merenja. Dijagram sa opisom strukture platforme dat je na slici 3.1.


Napomena: Kako su za predstavnike izabrani PostgresSQL i HBase, rezultati dobijeni u nastavku su rezultati poređenja konkretnih predstavnika, i nisu opšti za sve relacione i kolonski orijenisane nerelacione baze podataka.



\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{deployment_diagram.png}
  \caption{Platforma testiranja}
  \label{fig:grafikon}
\end{figure}

\pagebreak

\section{Primena u online transakcionom procesiranju (OLTP)}

Onlajn transakciono procesiranje obuhvata kratke, učestale invazivne operacije na relativno malom skupu podataka. Da bismo simulirali ovakvo okruženje korišćen je primer onlajn transakcija i prenosa sredstava sa jednog računa na drugi. Parametri testa će biti broj biznis transakcija koje treba izvršiti, kao i broj klijenata, odnoso konekcija ka bazi, koji će paralelno obavljati svoj deo posla u okviru ovog testa. Jedna biznis transakcija sastoji se iz kreiranja transakcije, izvršavanja transakcije, odnosno prenos sredstava sa jednog računa na drugi, i na kraju provera statusa transakcije. 


\subsection{Opis modela}

Model koji ćemo koristiti sastojaće se iz 4 tabele:

\begin{enumerate}
\item[\textbullet] \textbf{fxrates}: {
	Sadrži informacije o kursu valutnih parova
}
\item[\textbullet] \textbf{fxuser}:{
	Podaci o korisnicima
}
\item[\textbullet] \textbf{fxaccount}:{
	Podaci o računima korisnika.
}
\item[\textbullet] \textbf{fxtransaction}:{
	Transakcije prenosa sredstava
}
\end{enumerate}

\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={setup-postgres-model.sql},captionpos=t]

create table postgresdb.fxrates (
	currency_from  varchar(50) not null,
	currency_to varchar(50) not null,
	rate real not null,
	primary key(currency_from,currency_to)
);

create table postgresdb.fxuser (
	id  integer primary key,
	username varchar (50) unique not null,
	password varchar (50) not null,
	start_balancecurrency varchar (10) not null,
	start_balance real not null,
	firstname varchar(100) not null,
	lastname varchar(100) not null,
	street varchar(100) not null,
	city varchar(100) not null,
	state varchar(100) not null,
	zip varchar(50) not null,
	phone varchar(30) not null,
	mobile varchar(30) not null,
	email varchar(50) unique not null,
	created timestamp not null
);

create table postgresdb.fxaccount (
	id  integer primary key,
	fxuser integer not null  references postgresdb.fxuser(id),
	currency_code varchar(10) not null,
	balance real not null,
	created timestamp not null,
	unique (fxuser, currency_code)
);

create table postgresdb.fxtransaction (
	id integer primary key,
	fxaccount_from  integer references postgresdb.fxaccount(id),
	fxaccount_to  integer references postgresdb.fxaccount(id),
	amount numeric(15,2) not null,
	status varchar(50) not null,
	entry_date timestamp not null
);


\end{lstlisting}

\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={setup-hbase-model.sh},captionpos=t]
create fxrates, 'data';
create fxuser, 'data';
create fxaccount, 'data';
create fxtransaction, 'data';
\end{lstlisting}

\subsection{Implementacija testa}

Implementacija testa podrazumeva da ćemo imati dva parametra pri pokretanju: broj biznis transakcija koje će biti obrađene i broj klijenata koji će paralelno izvršavati svoj deo posla. Svakom klijentu će biti dodeljen određeni broj biznis transakcija koje treba da obradi. Svaka biznis transakcija sastoji se iz kreiranja transakcije (\textbf{createFXTransaction}), izvršavanja uplate (\textbf{executePayment}), provere statusa transakcije (\textbf{checkTransactionStatus}). 

CreateFXTransaction prvo pročita balans naloga sa kojeg treba preneti sredstva, nakon toga čita odgovarajući kurs, a ukoliko ima dovoljno sredstava na računu u tabelu sa transakcijama upisuje transakciju u statusu NEW.

\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1}
}

\begin{lstlisting}[title={CreateFXTransaction},captionpos=t]

select fa.balance
from fxaccount fa
where fa.id = ?;

select fr.rate
from fxrates fr
where fr.currency_to = ? and fr.currency_from = ?;

insert into fxtransaction
(id,fxaccount_from, fxaccount_to, amount, status, entry_date)
values(?,?,?,?,?,?)

\end{lstlisting}

ExecutePayment prvo pročita stanje sa naloga koji učestvuju u transakciji, menja im balans u skladu sa transakcijom, nakon toga transakciji menja status.



\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1}
}

\begin{lstlisting}[title={ExecutePayment},captionpos=t]

select balance
from fxaccount
where id = ?

update fxaccount
set balance = ?
where id = ?

select balance
from fxaccount
where id = ?

update fxaccount
set balance = ?
where id = ?

update fxtransaction
set status = ?
where id = ?

\end{lstlisting}

CheckTransactionStatus za odgovarajucu transakciju čita status.

\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1}
}

\begin{lstlisting}[title={CheckTransactionStatus},captionpos=t]
select status
from fxtransaction
where id = ?
\end{lstlisting}


Svaki klijent u zasebnoj niti obrađuje njemu dodeljen broj biznis transakcija, a svaka od njih se sastoji iz gore navedenih delova.

\lstset{
  language=Java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1}
}

\begin{lstlisting}[title={BenchmarkSingleClientExecutor.java},captionpos=t]

public class BenchmarkSingleClientExecutor implements Runnable {

    private final CountDownLatch endSignal;
    private final BenchmarkOLTPUtility oltpUtil;
    private final int numOfT;
    private final int startFrom;

    private final Object connection;

    @Override
    public void run() {

       try {
         for (int i = this.start; i < this.start + this.numOfT; i++) {
             ExecutePaymentInfo executePaymentInfo = 
	    oltpUtil.createFXTransaction(connection);
	    oltpUtil.executePayment(,executePaymentInfo);
            oltpUtil.checkTransactionStatus(fxT);
          }
          endSignal.countDown();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }
}

\end{lstlisting}



\subsection{Priprema okruženja}

S obzirom da se testovi izvršavaju na posebnim docker kontejnerima, potrebno  je da napravimo docker slike i pokrenemo kontejnere koristeći docker alat. Pored toga, neophodno je da kompajliramo java testove koristeći maven i nakon toga  prosledimo  odgovarajućim  kontejnerima.

\lstset{
  language=bash,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1}
}

\begin{lstlisting}[title={prepareEnv.sh},captionpos=t]
#!/bin/bash
echo 'PREPARING ENVIRONMENT...';

rm -f ./hbase_setup_model.jar
rm -f ./benchmark_hbase.jar
rm -f ./benchmark_postgres.jar

export JAVA_HOME="$JAVA_8";
mvn -f ./hbase_setup_model clean compile assembly:single;
mvn -f ./benchmark_hbase clean compile assembly:single;

export JAVA_HOME="$JAVA_17";
mvn -f ./benchmark_postgres clean compile assembly:single;


docker-compose -f docker-compose.yml up --build -d;
docker exec -it hbase-master-1 sh -c "java -jar hbase_setup_model.jar";

\end{lstlisting}

 Za pokretanje docker kontejnera korišćen je docker-compose sa sledećim sadržajem:

\lstset{
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={docker-compose.yml},captionpos=t]
services: 
  postgres:
    container_name: postgres
    ports:
      - "5433:5432"
    volumes:
      - ./setup_model.sql:/docker-entrypoint-initdb.d/create_script.sql
      - ./benchmark_postgres.jar:/benchmark_postgres.jar
    environment:
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_DB=postgresdb
    build:
      context: .
      dockerfile: ./Dockerfile_postgres

  hbase:
    image: bde2020/hbase-standalone:1.0.0-hbase1.2.6
    container_name: hbase
    volumes:
      - hbase_data:/hbase-data
      - hbase_zookeeper_data:/zookeeper-data
      - ./hbase_setup_model.jar:/hbase_setup_model.jar
      - ./benchmark_hbase.jar:/benchmark_hbase.jar
    ports:
      - 16000:16000
      - 16010:16010
      - 16020:16020
      - 16030:16030
      - 2888:2888
      - 3888:3888
      - 2181:2181

volumes:
  hbase_data:
  hbase_zookeeper_data:
\end{lstlisting}


\subsection{Analiza rezultata}

Kada se radi o OLTP okruženju, važno je naglasiti da HBase ne garantuje konzistentost nad svim podacima kakvu nudi Postgres. HBase ipak garantuje neki vid konzistentosti, tj konzistentost nad jednim redom tabele. To dovodi do zaključka da ukoliko je neophodno implementirati transakciju koja uključuje rad sa podacima više tabela ili više redova jedne tabele, ukoliko koristimo HBase moramo na aplikativnom sloju voditi računa o očuvanju  eventualne konzistetnosti. Postgres sa druge strane kao ACID baza sama garantuje da izmene neke transakcije koje se rade nad nekim skupom podataka neće biti vidljive za druge klijente dok se ta transakcija ne komituje, pa samim tim i konzistento stanje podataka.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{oltp-vizualization.png}
  \caption{Rezultati merenja u OLTP okruženju}
  \label{fig:grafikon}
\end{figure}

Merenje efikasnosti predstavnika u OLTP okruženju uključivalo je pokretanje testova u više iteracija. Svaki test je podrazumevao 5 klijenata koji paralelno obaljaju svoj deo posla, a pokrenuti su testovi za obradu \numprint{100},\numprint{1000}, \numprint{10000},\numprint{50000},\numprint{100000} biznis transakcija, a rezultati merenja prikazani su na slici 3.2. Primećuje se da sa porastom podataka koji se nalaze u tabeli sa čijim se podacima radi, Postgres ima određena usporenja, relativno gledano u odnosu na HBase. Konkretno kada se pogleda vreme delova biznis transakcije odvojeno, primećuje se da HBase u testovima sa \numprint{50000} i \numprint{100000} iteracija prednost stiče u createFXTransaction delu cele biznis transakcije, što se može videti na slici 3.3. 

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{createFxTransaction-vizualization.png}
  \caption{Rezultati merenja createFXTransaction dela biznis transakcije}
  \label{fig:grafikon}
\end{figure}

\pagebreak

Tendencija merenja ukazuje da bi sa porastom broja podataka (na milione i desetine miliona redova) HBase davao bolje rezultate u odnosu na Postgres, međutim za testiranje takvog okruženja neophodno je koristiti računar koji je sposoban da sprovede tako zahtevan test.


\section{Primena u online analitičkom procesiranju (OLAP)}

OLAP okruženje sačinjeno je od velikog broja čitanja podataka i vrlo malog broja izmena podataka.. Upiti koji se koriste obično imaju parametre, visok nivo kompleksnosti i visok procenat podataka kojima pristupaju.
Primer koji cemo koristiti jeste uopsten primer održavanja trgovinskog lanca koji ima skup mušterija, proizvoda, dobavljača,  narudžbina. 
Ovaj OLAP eksperiment će se sastojati iz dohvatanja izveštaja iz tabele koja sadrži stavke narudžbina. Taj izveštaj će sadržati rezultate agregiranih operacija nad kolonama, a parametri će biti status i datum slanja stavke.

\subsection{Modeli podataka}

Model koji ćemo koristiti sastojaće se iz sledećih tabela:

\begin{enumerate}
\item[\textbullet] \textbf{product}: {
	Sadrži informacije o proizvodima. Predviđeno je da sadrži 3000000 redova.
}
\item[\textbullet] \textbf{supplier}:{
	Podaci o dovaljačima. Predviđeno je da sadrži 1000000 redova.
}
\item[\textbullet] \textbf{productsupplier}:{
	Vezna tabela između dobavljača i proizvoda. Predviđeno je da sadrži 5000000 redova.
}
\item[\textbullet] \textbf{customer}:{
	Informacije o mušterijama. Predviđeno je da sadrži 1500000 redova.
}
\item[\textbullet] \textbf{order}:{
	Informacije o narudžbinama. Predviđeno je da sadrži 1500000 redova.
}
\item[\textbullet] \textbf{orderitem}:{
	Informacije o pojedinim stavkama narudžbine. Predviđeno je da sadrži 6000000 redova.
}

\end{enumerate}


\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={setup-postgres-model.sql},captionpos=t]


create table product (
    id  integer not null primary key,
    name varchar(50) not null,
    brand varchar(50) not null,
    type varchar(50) not null,
    size integer not null,
    container varchar(50) not null,
    price varchar(50) not null,
    comment varchar(50)
);

create table supplier (
    id  integer primary key,
    name varchar(50) not null,
    address varchar(200) not null,
    phone varchar(50) not null
);

create table productsupplier (
    id integer not null primary key,
    product integer not null,
    supplier integer not null,
    available integer not null,
    supply_cost real not null,
    comment varchar(200),
    constraint fk_product
    foreign key(product) references  postgresdb.product(id),
    constraint fk_supplier
    foreign key(supplier) references  postgresdb.supplier(id)
    
);

create table customer(
    id integer primary key,
    name varchar(50) not null,
    address varchar(200) not null,
    phone varchar(50) not null,
    comment varchar(200)
);

create table order(
    id integer primary key,
    customer integer not null,
    status varchar(20) not null,
    total_price real not null,
    entry_date date not null,
    priority varchar(20) not null,
    comment varchar(200),
    constraint fk_customer
    foreign key(customer) references  postgresdb.customer(id)
);

create table order_item(
    order_id integer not null,
    product integer not null,
    supplier integer not null, 
    order_no integer not null,
    quantity integer not null,
    base_price real not null,
    discount real not null,
    tax real not null,
    status varchar(20) not null,
    ship_date date not null,
    commit_date date not null,
    comment varchar(200),
    primary key(order_id,product,supplier),
    constraint fk_order
    foreign key(order_id) references  postgresdb.order(id),
    constraint fk_product
    foreign key(product) references  postgresdb.product(id),
    constraint fk_supplier
    foreign key(supplier) references  postgresdb.supplier(id)
);

\end{lstlisting}


\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={hbase-setup-model},captionpos=t]

create product, 'data';
create supplier, 'data';
create productsupplier, 'data';
create customer, 'data';
create order, 'data';
create orderitem, 'data';

\end{lstlisting}

\subsection{Implementacija testa}

Test će se sastojati iz dve faze. Bulk upunjavanje tabela na osnovu csv fajlova, kao i izvršavanje složenog OLAP upita. 

\lstset{
  language=sql,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}
\begin{lstlisting}[title={bulkLoad},captionpos=t]
copy product from "./product.csv";
copy supplier from "./supplier.csv";
copy productsupplier "./productsupplier.csv";
copy customer from "./customer.csv";
copy order from "./order.csv";
copy order_item from "./order_item.csv";
\end{lstlisting}

\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={BenchmarkExecutor.java},captionpos=t]

    void bulkLoad(BenchmarkUtility util,BenchmarkOLAPUtility oUtil) {
        long start = System.currentTimeMillis();
        olapUtility.bulkLoad(benchmarkUtility.connect());
        long end = System.currentTimeMillis();
        System.out.println("Bulk load duration: "+(end-start));
    }
\end{lstlisting}


OLAP upit sadrži informacije o agregiranim vrednostima kolona za određene vrednosti kolona. Upit će se izvršavati nad orderitem tabelom, a kao parametre uzimaće status i datum slanja stavke narudžbine.

\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={executeOLAPQuery},captionpos=t]

select
	oi.status status,
	sum(oi.quantity) as sum_qty,
        sum(oi.base_price) as sum_base_price,
        sum(oi.base_price*(1-oi.discount)) as sum_disc_price,
        sum(oi.base_price*(1-oi.discount)*(1+oi.tax)) as sum_charge,
        avg(oi.quantity) as avg_qty,
        avg(oi.base_price) as avg_price,
        avg(oi.discount) as avg_disc,
        count(*) as count_order
from
         postgresdb.order_item oi
where
        	oi.ship_date = to_date(?,'dd.mm.yyyy') and
         oi.status = ?

\end{lstlisting}

Parametri eksperimenta će biti broj iteracija izvršavanja OLAP upita kao i broj klijenata koji će paralelno izvršavati svoj deo posla u vidu određenog broja izvršavanja OLAP upita.


\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={BenchmarkSingleClientExecutor.java},captionpos=t]

public class BenchmarkSingleClientExecutor implements Runnable{

    private final CountDownLatch endSignal;
    private final BenchmarkOLAPUtility olapUtil;
    private final int numOfT;
    private final int start;

    private final Object connection;

    @Override
    public void run() {
        try {
            for (int i = this.start; i < this.start+this.numOfT; i++) {
                olapUtil.executeOLAPQuery(connection);
            }
            endSignal.countDown();
        } catch (Throwable e) {
            throw new IllegalStateException(e);
        }
    }
}

\end{lstlisting}

\subsection{Priprema okruženja}

Priprema okruženja je većinom identična kao priprema okruženja za OLTP slučaj upotrebe. Dodatan korak jedino je kreiranje csv fajlova sa podacima koji treba da budu bulk učitani u odgovarajuće tabele Postgres-a i HBase-a.
\pagebreak
\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={prepareEnv.sh},captionpos=t]
#!/bin/bash
echo 'PREPARING ENVIRONMENT...';
rm -f ./olap_benchmark_postgres.jar
rm -f ./olap_benchmark_hbase.jar
rm -f ./productHB.csv;
rm -f ./supplierHB.csv;
rm -f ./productsupplierHB.csv;
rm -f ./customerHB.csv;
rm -f ./orderHB.csv;
rm -f ./orderitemHB.csv;
rm -f ./productPG.csv;
rm -f ./supplierPG.csv;
rm -f ./productsupplierPG.csv;
rm -f ./customerPG.csv;
rm -f ./orderPG.csv;
rm -f ./orderitemPG.csv;


echo 'PREPARING HBASE BENCHMARK JARS...';
export JAVA_HOME="$JAVA_8";
mvn -f olap_benchmark_hbase clean compile assembly:single;
mvn -f hbase_setup_olap_model clean compile assembly:single;
mvn -f hbase_bulk_load_setup clean compile assembly:single;

echo 'PREPARING HBASE BULK LOAD RESOURCES..';
java -jar ./hbase_bulk_load_setup.jar;


echo 'PREPARING POSTGRES BENCHMARK JARS...';
export JAVA_HOME="$JAVA_17";
mvn -f olap_benchmark_postgres clean compile assembly:single;
mvn -f postgres_bulk_load_setup clean compile assembly:single;

echo 'PREPARING POSTGRES BULK LOAD RESOURCES..';
java -jar postgres_bulk_load_setup.jar;

docker-compose -f docker-compose.yml up --build -d;
winpty docker exec -it hbase sh -c "java -jar setup_olap_model.jar";

\end{lstlisting}


\pagebreak

 Za pokretanje docker kontejnera korišćen je docker-compose sa sledećim sadržajem:

\lstset{
  language=java,
  basicstyle=\footnotesize,
  keywordstyle=\color{black},
  backgroundcolor = \color{LemonChiffon1},
  numbers=left,
  showstringspaces=false,
  frame=single
}

\begin{lstlisting}[title={docker-compose.yml},captionpos=t]

services: 
  postgres:
    container_name: postgres
    ports:
      - "5433:5432"
    volumes:
      - ./setup_model.sql:/docker-entrypoint-initdb.d/create_script.sql
      - ./benchmark_postgres.jar:/benchmark_postgres.jar
    environment:
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_DB=postgresdb
    build:
      context: .
      dockerfile: ./Dockerfile_postgres

  hbase:
    image: bde2020/hbase-standalone:1.0.0-hbase1.2.6
    container_name: hbase
    volumes:
      - ./productsupplierHB.csv:/productsupplier.csv
      - ./productHB.csv:/product.csv
      - ./supplierHB.csv:/supplier.csv
      - ./customerHB.csv:/customer.csv
      - ./orderHB.csv:/order.csv
      - ./orderitemHB.csv:/orderitem.csv
      - ./orderitemStatsHB.csv:/orderitemstats.csv
      - hbase_data:/hbase-data
      - hbase_zookeeper_data:/zookeeper-data
      - ./hbase_setup_model.jar:/hbase_setup_model.jar
      - ./benchmark_hbase.jar:/benchmark_hbase.jar
    ports:
      - 16000:16000
      - 16010:16010
      - 16020:16020
      - 16030:16030
      - 2888:2888
      - 3888:3888
      - 2181:2181

volumes:
  hbase_data:
  hbase_zookeeper_data:
\end{lstlisting}


\subsection{Analiza rezultata}

Rezultati merenja pokazuju jasnu prednost Postgres-a u odnosu na HBase u ovakvom okruženju, koristeći ravnopravne modele. Sa druge strane, ovakav pristup gde mi dohvatamo sve redove po statusu i datumu, pa se nad vrednostima izvršavaju odgovarajuće aritmetičke operacije, može se nazvati \textit{"naivnim"} u slučaju HBase-a. 

Jednostavna denormalizacija modela, slika 3.4 može doneti dramatična poboljšanja u performansama HBase-a čak i u odnosu na Postgres.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\textwidth]{denormalized-model.png}
  \caption{Denormalizacija na primeru tabele orderitem}
  \label{fig:grafikon}
\end{figure}

Izdvajanje tabele \textbf{orderitemstats}, koja će za ključ imati status orderitema, a kao kolone imati rezultate već ranije izračunatih agregiranih vrednosti nad kolonama za odgovarajuče dane, dovodi do toga da dohvatanje izveštaja sada predstavlja jednostavno dohvatanje reda po ključu i skupa odgovarajućih kolona koje su nam potrebne za izveštaj.

Uticaj denormalizacije modela na performanse mogu se videti na slici 3.5.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\textwidth]{olap-vizualization.png}
  \caption{Uporedna analiza performansi postgresa i hbase-a}
  \label{fig:grafikon}
\end{figure}

Ovakav pristup prilikom kreiranja modela, omogućila nam je fleksibilnost sheme koju HBase nudi, ali i nepostojanje limita broja kolona. 

\pagebreak


\section{Primena u distribuiranom okruženju}
\subsection{CAP teorema}

\chapter{Zaključak}

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
\textbf{Вук Стефановић Караџић} (\emph{Тршић, 26. октобар/6. новембар
  1787. — Беч, 7. фебруар 1864.}) био је српски филолог, реформатор
српског језика, сакупљач народних умотворина и писац првог речника
српског језика.  Вук је најзначајнија личност српске књижевности прве
половине XIX века. Стекао је и неколико почасних доктората.
Учествовао је у Првом српском устанку као писар и чиновник у
Неготинској крајини, а након слома устанка преселио се у Беч,
1813. године. Ту је упознао Јернеја Копитара, цензора словенских
књига, на чији је подстицај кренуо у прикупљање српских народних
песама, реформу ћирилице и борбу за увођење народног језика у српску
књижевност. Вуковим реформама у српски језик је уведен фонетски
правопис, а српски језик је потиснуо славеносрпски језик који је у то
време био језик образованих људи. Тако се као најважније године Вукове
реформе истичу 1818., 1836., 1839., 1847. и 1852.
\end{biografija}
% ------------------------------------------------------------------------------

\end{document} 